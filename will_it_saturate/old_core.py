# AUTOGENERATED! DO NOT EDIT! File to edit: 25_core.ipynb (unless otherwise specified).

__all__ = ['get_macos_machine_id', 'get_linux_machine_id', 'get_machine_id', 'Benchmark']

# Cell

import os
import math
import json
import hashlib

import pandas as pd

from pathlib import Path
from urllib.parse import urljoin
from typing import Optional, Callable, Any

from pydantic import BaseModel

from .epochs import Epoch
from .results import Result
from .servers import BaseServer
from .clients import BaseClient
from .files import BenchmarkFile, FILE_CREATORS
from .repositories import BaseRepository, InMemoryRepository

# Cell
import cpuinfo
import platform
import subprocess

from pathlib import Path
from functools import cache


def get_macos_machine_id():
    kwargs = {"capture_output": True, "text": True}
    output = subprocess.run(
        [
            "/usr/sbin/system_profiler",
            "SPHardwareDataType",
        ],
        **kwargs,
    )
    machine_id = None
    for line in output.stdout.split("\n"):
        if "Serial Number" in line:
            machine_id = line.split()[-1]
    return machine_id


def get_linux_machine_id():
    machine_id = "linux_dummy"
    with Path("/etc/machine-id").open() as f:
        machine_id = f.read().rstrip()
    return machine_id


@cache
def get_machine_id():
    os = platform.platform().lower().split("-")[0]
    os_lookup = {"macos": get_macos_machine_id, "linux": get_linux_machine_id}
    return os_lookup[os]()


class Benchmark(BaseModel):
    duration: int = 30  # in seconds
    bandwidth: int = int(10 ** 9 / 8)  # in bytes per second
    file_sizes: list[int] = [10 ** 7, 10 ** 6, 10 ** 5]
    epochs: list[Epoch] = []
    file_creator_name: str = "filesystem"
    uname: Optional[Any] = platform.uname()
    cpuinfo: Optional[dict] = cpuinfo.get_cpu_info()
    servers: list[BaseServer] = []
    clients: list[BaseClient] = []
    results: list[Result] = []
    repository: Optional[BaseRepository] = None
    machine_id: str = get_machine_id()

    @property
    def uname_json(self):
        return json.dumps(self.uname)

    def __hash__(self):
        return hash(self.machine_id)

    def __eq__(self, other):
        self.machine_id == other.machine_id

    def create_epoch_from_file_size(self, file_size):
        do_not_copy = {
            "rows",
            "file_sizes",
            "servers",
            "clients",
            "results",
            "repository",
        }
        kwargs = {k: v for k, v in dict(self).items() if k not in do_not_copy}
        epoch = Epoch(file_size=file_size, **kwargs)
        epoch.create_files()
        return epoch

    def create_epochs(self):
        if len(self.epochs) > 0:
            # benchmark rows were already created
            return

        # create a row for each file_size
        for file_size in self.file_sizes:
            self.epochs.append(self.create_epoch_from_file_size(file_size))

    def build_empty_result(self, epoch, server, client):
        return Result(
            server=server.name,
            client=client.name,
            file_size=epoch.file_size,
            elapsed=elapsed,
            complete_size=epoch.complete_size,
            platform=self.uname.machine,
        )

    def test_server_with_client(self, server, client):
        for epoch in self.epochs:
            result = Result.build_empty_result(epoch, server, client)
            if (
                self.repository is not None
                and (
                    already_measured := self.repository.get_result(self, result)
                ).elapsed
                is not None
            ):
                print("already measured: ", already_measured)
                result = already_measured
            else:
                if not server.started:
                    server.start()
                result.elapsed = client.measure(epoch)
                if self.repository is not None:
                    self.repository.add_result(self, result)
                print("measured: ", result)
            self.results.append(result)

    def run(self):
        for server in self.servers:
            # start with servers, because they are more expensive to create
            print(f"server: {server}")
            for client in self.clients:
                self.test_server_with_client(server, client)
            if server.started:
                server.stop()

    def json(self):
        # return super().json(exclude={"rows", "repository"})
        fields = {
            "duration",
            "bandwidth",
            "cpuinfo",
        }
        return super().json(include=fields)

    @property
    def results_frame(self):
        return pd.DataFrame([r.dict_with_properties() for r in self.results])