# AUTOGENERATED! DO NOT EDIT! File to edit: 71_sqlite_repository.ipynb (unless otherwise specified).

__all__ = ['BaseRepository', 'InMemoryRepository', 'dict_factory', 'SqliteRepository']

# Cell

from typing import Any
from pydantic import BaseModel
from collections import defaultdict


class BaseRepository(BaseModel):
    session: Any = None

    def get_result(self, benchmark, result):
        pass

    def add_result(self, benchmark, result):
        pass


class InMemoryRepository(BaseRepository):
    results: dict = defaultdict(dict)

    def get_result(self, benchmark, result):
        return self.results.get(benchmark, {}).get(result, result)

    def add_result(self, benchmark, result):
        self.results[benchmark][result] = result

# Cell

import json
import sqlite3


def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d


class SqliteRepository(BaseRepository):
    connection: sqlite3.Connection

    class Config:
        arbitrary_types_allowed = True

    def execute_stmt(self, stmt, ignore_error=False):
        cursor = self.connection.cursor()
        try:
            cursor.execute(stmt)
        except sqlite3.OperationalError as exc:
            if not ignore_error:
                raise (exc)

    def create_benchmark_table(self):
        stmt = """
            create table benchmark (
                benchmark_id INTEGER PRIMARY KEY,
                created DATE DEFAULT (datetime('now','localtime')),
                machine_id TEXT NOT NULL UNIQUE,
                uname TEXT NOT NULL,
                data TEXT NOT NULL
            )
        """
        self.execute_stmt(stmt, ignore_error=True)

    def create_host_table(self):
        stmt = """
            create table host (
                host_id INTEGER PRIMARY KEY,
                created DATE DEFAULT (datetime('now','localtime')),
                machine_id TEXT NOT NULL UNIQUE,
                data TEXT NOT NULL
            )
        """
        self.execute_stmt(stmt, ignore_error=True)

    def create_result_table(self):
        stmt = """
            create table result (
                result_id INTEGER PRIMARY KEY,
                server_host_id integer not NULL,
                client_host_id integer not NULL,
                created DATE DEFAULT (datetime('now','localtime')),
                server text not NULL,
                client text not NULL,
                file_size integer not NULL,
                complete_size integer not NULL,
                elapsed real not NULL,
                FOREIGN KEY(server_host_id) REFERENCES host(host_id)
                FOREIGN KEY(client_host_id) REFERENCES host(host_id)
            )
        """
        self.execute_stmt(stmt, ignore_error=True)

    def create_tables(self):
        self.create_host_table()
        self.create_result_table()

    def add_benchmark(self, benchmark):
        stmt = """
            insert into benchmark (machine_id, uname, data)
            values (?, ?, ?)
        """
        cursor = self.connection.cursor()
        machine_id = benchmark.machine_id
        uname = benchmark.uname_json
        data = benchmark.json()
        try:
            cursor = cursor.execute(stmt, [machine_id, uname, data])
        except sqlite3.IntegrityError as e:
            pass
        self.connection.commit()

    def get_benchmark(self, benchmark):
        stmt = """
            select *
              from benchmark
             where machine_id=?
        """
        cursor = self.connection.cursor()
        cursor.execute(stmt, [benchmark.machine_id])
        return cursor.fetchone()

    def get_benchmark_id(self, benchmark):
        row = self.get_benchmark(benchmark)
        if row is None:
            return row
        return row[0]

    def get_machine_to_host_id(self, machine_ids):
        question_marks = ", ".join(["?" for _ in machine_ids])
        stmt = f"""
            select host_id, machine_id
              from host
             where machine_id in ({question_marks})
        """
        cursor = self.connection.cursor()
        cursor.execute(stmt, machine_ids)
        rows = cursor.fetchall()
        return {row["machine_id"]: row["host_id"] for row in rows}

    def insert_host_details(self, host_details):
        stmt = """
            insert into host (machine_id, data)
            values (?, ?)
        """
        cursor = self.connection.cursor()
        try:
            cursor = cursor.execute(
                stmt, [host_details.machine_id, host_details.json()]
            )
        except sqlite3.IntegrityError as e:
            pass
        self.connection.commit()
        return cursor.rowcount

    def get_result(self, benchmark, result):
        benchmark_id = self.get_benchmark_id(benchmark)
        if benchmark_id is None:
            self.add_benchmark(benchmark)
        benchmark_id = self.get_benchmark_id(benchmark)
        assert benchmark_id is not None
        stmt = """
            select *
              from result
             where benchmark_id=?
               and server=?
               and client=?
               and file_size=?
               and complete_size=?
        """
        cursor = self.connection.cursor()
        cursor.execute(
            stmt,
            [
                benchmark_id,
                result.server,
                result.client,
                result.file_size,
                result.complete_size,
            ],
        )
        row = cursor.fetchone()
        if row is None:
            return result
        result.elapsed = row[7]
        return result

    def get_results(self):
        stmt = """
            select *
              from result
        """
        cursor = self.connection.cursor()
        cursor.execute(stmt)
        rows = cursor.fetchall()
        return rows

    def get_or_create_hosts_from_result(self, result):
        machine_id_to_server_details = {
            result.server_details.machine_id: result.server_details,
            result.client_details.machine_id: result.client_details,
        }
        machine_ids = list(machine_id_to_server_details.keys())
        machine_to_host_id = self.get_machine_to_host_id(machine_ids)
        for machine_id, host_detail in machine_id_to_server_details.items():
            if machine_id not in machine_to_host_id:
                self.insert_host_details(host_detail)
        return self.get_machine_to_host_id(machine_ids)

    def add_result(self, result):
        machine_to_host_id = self.get_or_create_hosts_from_result(result)
        result_row = {
            "server_host_id": machine_to_host_id[result.server_details.machine_id],
            "client_host_id": machine_to_host_id[result.client_details.machine_id],
            "server": result.server.json(),
            "client": result.client.json(),
            "file_size": result.file_size,
            "complete_size": result.complete_size,
            "elapsed": result.elapsed,
        }
        columns = list(result_row.keys())
        columns_str = ",".join(columns)
        values_str = ",".join(["?" for c in columns])

        stmt = f"""
            insert into result ({columns_str})
            values ({values_str})
        """
        cursor = self.connection.cursor()

        values = [result_row[c] for c in columns]
        try:
            cursor = cursor.execute(stmt, values)
        except sqlite3.IntegrityError as e:
            pass
        self.connection.commit()
        return cursor.rowcount

    @classmethod
    def build_repository(cls, database_name):
        conn = sqlite3.connect(database_name)
        conn.row_factory = dict_factory
        repo = cls(connection=conn)
        repo.create_tables()
        return repo