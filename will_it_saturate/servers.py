# AUTOGENERATED! DO NOT EDIT! File to edit: 16_servers_started_via_docker.ipynb (unless otherwise specified).

__all__ = ['BaseServer', 'FastAPIUvicornServer', 'DjangoGunicornWSGIServer', 'CaddyFileServer', 'NginxFileServer',
           'NginxSendfileServer', 'NginxDockerServer']

# Cell

import time
import subprocess

from pydantic import BaseModel

from .files import BenchmarkFile
from .registry import register_model


@register_model
class BaseServer(BaseModel):
    protocol: str = "http"
    name: str = "base_server"
    host: str = "localhost"
    port: int = 8000
    view: str = ""

    def start(self):
        pass

    def stop(self):
        pass

    def is_running(self):
        return False

    def file_to_url(self, file: BenchmarkFile):
        path = f"{self.view}/{file.path}" if self.view else f"{file.path}"
        return f"{self.protocol}://{self.host}:{self.port}/{path}"

    def params(self):
        return {
            "class_name": self.__class__.__name__,
            "parameters": self.dict(),
        }

# Cell


@register_model
class FastAPIUvicornServer(BaseServer):
    name: str = "fastAPI/uvicorn"

    def get_pid(self):
        kwargs = {"shell": True, "capture_output": True, "text": True}
        output = subprocess.run(
            f"ps aux | grep will_it_saturate.fastapi.main:app", **kwargs
        )
        lines = [l for l in output.stdout.split("\n") if len(l) > 0 and "grep" not in l]
        if len(lines) > 0:
            pid = lines[0].split()[1]
            return pid

    @property
    def started(self):
        return self.get_pid() is not None

    def start_server(self):
        subprocess.Popen(
            [
                "uvicorn",
                "--host",
                str(self.host),
                "--port",
                str(self.port),
                "--no-access-log",
                "will_it_saturate.fastapi.main:app",
            ]
        )
        # subprocess.Popen(["uvicorn", "will_it_saturate.fastapi.main:app"])

    def stop_server(self):
        subprocess.check_output(["kill", self.get_pid()])
        time.sleep(1)  # dunno why this is necessary

    def start(self):
        if not self.started:
            self.start_server()

    def stop(self):
        if self.started:
            self.stop_server()

# Cell


@register_model
class DjangoGunicornWSGIServer(BaseServer):
    name: str = "django/gunicorn/wsgi"

    def get_pids(self):
        kwargs = {"shell": True, "capture_output": True, "text": True}
        output = subprocess.run(f"ps aux | grep will_it_saturate.django.wsgi", **kwargs)
        lines = [l for l in output.stdout.split("\n") if len(l) > 0 and "grep" not in l]
        print(len(lines))
        pids = []
        for line in lines:
            pid = line.split()[1]
            pids.append(pid)
        return pids

    @property
    def started(self):
        return len(self.get_pids()) > 0

    def start_server(self):
        subprocess.Popen(
            [
                "gunicorn",
                "--backlog",
                "10000",
                "-w",
                "8",
                "-b" f":{self.port}",
                "will_it_saturate.django.wsgi",
            ]
        )
        time.sleep(2)

    def stop_server(self):
        kill_command = ["kill"]
        kill_command.extend(self.get_pids())
        subprocess.check_output(kill_command)
        time.sleep(1)  # dunno why this is necessary

    def start(self):
        if not self.started:
            self.start_server()

    def stop(self):
        if self.started:
            self.stop_server()

# Cell


@register_model
class CaddyFileServer(BaseServer):
    name: str = "caddy"

    def get_pids(self):
        kwargs = {"shell": True, "capture_output": True, "text": True}
        output = subprocess.run(f"ps aux | grep -i caddy", **kwargs)
        lines = [l for l in output.stdout.split("\n") if len(l) > 0 and "grep" not in l]
        print(len(lines))
        pids = []
        for line in lines:
            pid = line.split()[1]
            pids.append(pid)
        return pids

    @property
    def started(self):
        return len(self.get_pids()) > 0

    def start_server(self):
        subprocess.Popen(
            [
                "caddy",
                "file-server",
                "--listen",
                f"0.0.0.0:{self.port}",
            ]
        )
        time.sleep(2)

    def stop_server(self):
        kill_command = ["kill"]
        kill_command.extend(self.get_pids())
        subprocess.check_output(kill_command)
        time.sleep(1)  # dunno why this is necessary

    def start(self):
        if not self.started:
            self.start_server()

    def stop(self):
        if self.started:
            self.stop_server()

# Cell

from pathlib import Path


@register_model
class NginxFileServer(BaseServer):
    name: str = "nginx/minimal"

    def get_pids(self):
        kwargs = {"shell": True, "capture_output": True, "text": True}
        output = subprocess.run(f"ps aux | grep -i nginx", **kwargs)
        lines = [l for l in output.stdout.split("\n") if len(l) > 0 and "grep" not in l]
        print(len(lines))
        pids = []
        for line in lines:
            pid = line.split()[1]
            pids.append(pid)
        return pids

    @property
    def started(self):
        return len(self.get_pids()) > 0

    def create_config(self):
        cwd = Path.cwd()
        server_root = str(cwd)
        config = f"""
daemon off;
events {{}}
http {{
    server {{
        listen {self.port};
        sendfile           off;
        tcp_nopush         off;
        tcp_nodelay        off;
        root {server_root};
    }}
}}
        """
        config_path = cwd / "nginx.conf"
        with config_path.open("w") as f:
            f.write(config)
        return config_path

    def start_server(self):
        config_path = self.create_config()
        subprocess.Popen(
            [
                "nginx",
                "-c",
                str(config_path),
            ]
        )
        time.sleep(2)

    def stop_server(self):
        kill_command = ["kill"]
        kill_command.extend(self.get_pids())
        subprocess.check_output(kill_command)
        time.sleep(1)  # dunno why this is necessary

    def start(self):
        if not self.started:
            self.start_server()

    def stop(self):
        if self.started:
            self.stop_server()


@register_model
class NginxSendfileServer(NginxFileServer):
    name: str = "nginx/sendfile"

    def create_config(self):
        cwd = Path.cwd()
        server_root = str(cwd)
        config = f"""
daemon off;
events {{}}
http {{
    server {{
        listen    {self.port};
        sendfile           on;
        sendfile_max_chunk 1m;
        tcp_nopush         on;
        tcp_nodelay        on;
        keepalive_timeout  65;
        root {server_root};
    }}
}}
        """
        print(config)
        config_path = cwd / "nginx.conf"
        with config_path.open("w") as f:
            f.write(config)
        return config_path

# Cell

from pathlib import Path
from .registry import register_model


@register_model
class NginxDockerServer(BaseServer):
    name: str = "nginx/docker"
    docker_name: str = "wis-nginx"
    port: int = 8000
    data_root: str = "data"
    subprocess_kwargs = {"shell": True, "capture_output": True, "text": True}

    def write_dockerfile(self):
        dockerfile = f"""
        FROM nginx
        COPY {self.data_root} /usr/share/nginx/html/{self.data_root}
        """
        with Path("Dockerfile.nginx").open("w") as f:
            f.write(dockerfile)

    @property
    def docker_id(self):
        output = subprocess.run(
            f"docker ps | grep {self.docker_name}", **self.subprocess_kwargs
        )
        if len(output.stdout) > 0:
            return output.stdout.split()[0]

    @property
    def started(self):
        return self.docker_id is not None

    def stop_container(self, docker_id):
        output = subprocess.run(f"docker kill {docker_id}", **self.subprocess_kwargs)
        print(output.stdout)

    def remove_container(self):
        output = subprocess.run(
            f"docker rm {self.docker_name}", **self.subprocess_kwargs
        )
        print(output.stdout)

    def build_container(self):
        output = subprocess.run(
            f"docker build -f Dockerfile.nginx -t {self.docker_name} .",
            **self.subprocess_kwargs,
        )
        print(output.stdout)

    def start_container(self):
        output = subprocess.run(
            f"docker run --name {self.docker_name} -d -p {self.port}:80 {self.docker_name}",
            **self.subprocess_kwargs,
        )
        print(output.stdout)

    def start_server(self):
        self.write_dockerfile()
        self.remove_container()
        self.build_container()
        self.start_container()

    def stop_server(self):
        if self.started:
            self.stop_container(self.docker_id)
            self.remove_container()
        time.sleep(1)  # dunno why this is necessary

    def start(self):
        if not self.started:
            self.start_server()

    def stop(self):
        if self.started:
            self.stop_server()