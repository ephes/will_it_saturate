# AUTOGENERATED! DO NOT EDIT! File to edit: 14_django_http.ipynb (unless otherwise specified).

__all__ = ['logger', 'MeasuringFileResponse', 'AsyncFileResponse', 'AsyncMinioResponse', 'AWS_ACCESS_KEY_ID',
           'AWS_SECRET_ACCESS_KEY']

# Cell

import time
import logging

from django.http import FileResponse

logger = logging.getLogger(__name__)

# Cell


class MeasuringFileResponse(FileResponse):
    def __init__(self, *args, **kwargs):
        self.open_file_name = args[0].name
        self.started_serving = time.perf_counter()
        super().__init__(*args, **kwargs)

    def close(self):
        super().close()
        elapsed = time.perf_counter() - self.started_serving
        # print(f"elapsed: {elapsed} for {self.open_file_name}")
        logger.info(f"{self.open_file_name},{elapsed}")

# Cell

import aiofiles


class AsyncFileResponse(FileResponse):
    def __init__(self, *args, **kwargs):
        self.started_serving = time.perf_counter()
        self.chunk_size = kwargs.get("chunk_size", 4096)
        self.async_file = None
        self.more_body = True
        super().__init__(*args, **kwargs)
        self.headers["Content-Type"] = "application/octet-stream"

    def __aiter__(self):
        return self

    async def __anext__(self):
        if self.async_file is None:
            self.async_file = await aiofiles.open(self.filename, mode="rb")
        while self.more_body:
            chunk = await self.async_file.read(self.chunk_size)
            self.more_body = len(chunk) == self.chunk_size
            return self.more_body, chunk
        await self.async_file.close()
        raise StopAsyncIteration

    def close(self):
        super().close()
        elapsed = time.perf_counter() - self.started_serving
        logger.info(f"{self.filename},{elapsed}")

# Cell

import aiobotocore

AWS_ACCESS_KEY_ID = "minioadmin"
AWS_SECRET_ACCESS_KEY = "minioadmin"

# session = aiobotocore.get_session()


class AsyncMinioResponse(FileResponse):
    minio = True

    def __init__(self, *args, **kwargs):
        self.started_serving = time.perf_counter()
        self.chunk_size = kwargs.pop("chunk_size", 4096)
        self.bucket = kwargs.pop("bucket", None)
        self.key = kwargs.pop("key", None)
        self.filename = self.key
        super().__init__(*args, **kwargs)
        self.headers["Content-Type"] = "application/octet-stream"

#     def __aiter__(self):
#         return self

#     async def __anext__(self):
#         while self.more_body:
#             chunk = await self.minio_stream.read(self.chunk_size)
#             self.more_body = len(chunk) == self.chunk_size
#             return self.more_body, chunk

#         self.client.close()
#         raise StopAsyncIteration

    def close(self):
        super().close()
        elapsed = time.perf_counter() - self.started_serving
        logger.info(f"{self.filename},{elapsed}")