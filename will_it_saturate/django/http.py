# AUTOGENERATED! DO NOT EDIT! File to edit: 14_django_http.ipynb (unless otherwise specified).

__all__ = ['logger', 'MeasuringFileResponse', 'AsyncFileResponse']

# Cell

import time
import logging

from django.http import FileResponse

logger = logging.getLogger(__name__)

# Cell


class MeasuringFileResponse(FileResponse):
    def __init__(self, *args, **kwargs):
        self.open_file_name = args[0].name
        self.started_serving = time.perf_counter()
        super().__init__(*args, **kwargs)

    def close(self):
        super().close()
        elapsed = time.perf_counter() - self.started_serving
        # print(f"elapsed: {elapsed} for {self.open_file_name}")
        logger.info(f"{self.open_file_name},{elapsed}")

# Cell

import aiofiles


class AsyncFileResponse(FileResponse):
    def __init__(self, *args, **kwargs):
        self.started_serving = time.perf_counter()
        self.chunk_size = kwargs.get("chunk_size", 4096)
        self.async_file = None
        self.more_body = True
        super().__init__(*args, **kwargs)
        self.headers["Content-Type"] = "application/octet-stream"

    def __aiter__(self):
        return self

    async def __anext__(self):
        if self.async_file is None:
            self.async_file = await aiofiles.open(self.filename, mode="rb")
        while self.more_body:
            chunk = await self.async_file.read(self.chunk_size)
            self.more_body = len(chunk) == self.chunk_size
            return self.more_body, chunk
        await self.async_file.close()
        raise StopAsyncIteration

    def close(self):
        super().close()
        elapsed = time.perf_counter() - self.started_serving
        logger.info(f"{self.filename},{elapsed}")