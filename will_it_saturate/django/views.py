# AUTOGENERATED! DO NOT EDIT! File to edit: 12_views_for_django_server.ipynb (unless otherwise specified).

__all__ = ['IS_ASYNC', 'MeasuringFileResponse', 'serve_file_sync', 'serve_file_async', 'set_serve_file_to_async',
           'serve_file']

# Cell
from pathlib import Path

from django.http import JsonResponse
from django.http import FileResponse

from .http import AsyncFileResponse


IS_ASYNC = False

# Cell

import time

from django.core import signals


class MeasuringFileResponse(FileResponse):
    def __init__(self, *args, **kwargs):
        # open_file = args[0]
        # print(f"starting to serve: {open_file.name}")
        self.open_file_name = args[0].name
        self.started_serving = time.perf_counter()
        super().__init__(*args, **kwargs)

    def close(self):
        elapsed = time.perf_counter() - self.started_serving
        print(f"elapsed: {elapsed} for {self.open_file_name}")
        for closer in self._resource_closers:
            try:
                closer()
            except Exception:
                pass
        # Free resources that were still referenced.
        self._resource_closers.clear()
        self.closed = True
        signals.request_finished.send(sender=self._handler_class)

# Cell


async def serve_file_sync(request, base, path, num):
    file_path = Path(base) / path / str(num)
    return MeasuringFileResponse(file_path.open("rb"))


async def serve_file_async(request, base, path, num):
    file_path = Path(base) / path / str(num)
    # print(f"serving file {file_path}")
    response = AsyncFileResponse(filename=file_path)
    response.headers["Content-Type"] = "application/octet-stream"
    return response


serve_file = serve_file_sync


def set_serve_file_to_async():
    global serve_file
    serve_file = serve_file_async