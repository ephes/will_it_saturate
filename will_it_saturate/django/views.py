# AUTOGENERATED! DO NOT EDIT! File to edit: 12_views_for_django_server.ipynb (unless otherwise specified).

__all__ = ['MeasuringFileResponse', 'serve_file_sync', 'serve_file']

# Cell
from pathlib import Path

from django.http import JsonResponse
from django.http import FileResponse

from .http import AsyncFileResponse

# Cell

import time

from django.core import signals


class MeasuringFileResponse(FileResponse):
    def __init__(self, *args, **kwargs):
        # open_file = args[0]
        # print(f"starting to serve: {open_file.name}")
        self.open_file_name = args[0].name
        self.started_serving = time.perf_counter()
        super().__init__(*args, **kwargs)

    def close(self):
        elapsed = time.perf_counter() - self.started_serving
        print(f"elapsed: {elapsed} for {self.open_file_name}")
        for closer in self._resource_closers:
            try:
                closer()
            except Exception:
                pass
        # Free resources that were still referenced.
        self._resource_closers.clear()
        self.closed = True
        signals.request_finished.send(sender=self._handler_class)

# Cell


async def serve_file_sync(request, base, path, num):
    file_path = Path(base) / path / str(num)
    # return JsonResponse({"file_path": file_path})
    return MeasuringFileResponse(file_path.open("rb"))
    # return FileResponse(file_path.open("rb"))

# Cell


# class AsyncFileResponse(FileResponse):
#     async_file_response = True
#     chunk_size = 4096


# class AsyncFileResponse2(FileResponse):
#     async_file_response = True
#     chunk_size = 4096


async def serve_file(request, base, path, num):
    file_path = Path(base) / path / str(num)
    # print(f"serving file {file_path}")
    response = AsyncFileResponse(filename=file_path)
    response.headers["Content-Type"] = "application/octet-stream"
    # response = FileResponse(file_path.open("rb"))
    # response.async_file_response = False
    return response
    # return AsyncFileResponse(file_path)