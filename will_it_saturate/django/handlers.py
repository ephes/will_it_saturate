# AUTOGENERATED! DO NOT EDIT! File to edit: 13_django_handlers.ipynb (unless otherwise specified).

__all__ = ['AsyncFileASGIHandler', 'AsyncMinioASGIHandler', 'AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY']

# Cell

from asgiref.sync import sync_to_async
from django.core.handlers.asgi import ASGIHandler

# Cell


class AsyncFileASGIHandler(ASGIHandler):
    async def send_response(self, response, send):
        """Encode and send a response out over ASGI."""
        # Collect cookies into headers. Have to preserve header case as there
        # are some non-RFC compliant clients that require e.g. Content-Type.
        response_headers = []
        for header, value in response.items():
            if isinstance(header, str):
                header = header.encode("ascii")
            if isinstance(value, str):
                value = value.encode("latin1")
            response_headers.append((bytes(header), bytes(value)))
        for c in response.cookies.values():
            response_headers.append(
                (b"Set-Cookie", c.output(header="").encode("ascii").strip())
            )
        # Initial response message.
        await send(
            {
                "type": "http.response.start",
                "status": response.status_code,
                "headers": response_headers,
            }
        )
        # Streaming responses need to be pinned to their iterator.
        if response.streaming:
            is_async_file_response = hasattr(response, "__aiter__")
            if is_async_file_response:
                async for more_body, chunk in response:
                    await send(
                        {
                            "type": "http.response.body",
                            "body": chunk,
                            "more_body": more_body,
                        }
                    )

            else:
                # Access `__iter__` and not `streaming_content` directly in case
                # it has been overridden in a subclass.
                for part in response:
                    for chunk, _ in self.chunk_bytes(part):
                        await send(
                            {
                                "type": "http.response.body",
                                "body": chunk,
                                # Ignore "more" as there may be more parts; instead,
                                # use an empty final closing message with False.
                                "more_body": True,
                            }
                        )
                # Final closing message.
                await send({"type": "http.response.body"})
        # Other responses just need chunking.
        else:
            # Yield chunks of response.
            for chunk, last in self.chunk_bytes(response.content):
                await send(
                    {
                        "type": "http.response.body",
                        "body": chunk,
                        "more_body": not last,
                    }
                )
        await sync_to_async(response.close, thread_sensitive=True)()

# Cell

import aiobotocore

AWS_ACCESS_KEY_ID = "minioadmin"
AWS_SECRET_ACCESS_KEY = "minioadmin"

# session = aiobotocore.get_session()


class AsyncMinioASGIHandler(ASGIHandler):
    async def send_response(self, response, send):
        """Encode and send a response out over ASGI."""
        # Collect cookies into headers. Have to preserve header case as there
        # are some non-RFC compliant clients that require e.g. Content-Type.
        response_headers = []
        for header, value in response.items():
            if isinstance(header, str):
                header = header.encode("ascii")
            if isinstance(value, str):
                value = value.encode("latin1")
            response_headers.append((bytes(header), bytes(value)))
        for c in response.cookies.values():
            response_headers.append(
                (b"Set-Cookie", c.output(header="").encode("ascii").strip())
            )
        # Initial response message.
        await send(
            {
                "type": "http.response.start",
                "status": response.status_code,
                "headers": response_headers,
            }
        )
        # Streaming responses need to be pinned to their iterator.
        if response.streaming:
            is_minio_file_response = hasattr(response, "minio")
            if is_minio_file_response:
                session = aiobotocore.get_session()
                async with session.create_client(
                    "s3",
                    endpoint_url="http://localhost:9000",
                    region_name="us-west-2",
                    aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
                    aws_access_key_id=AWS_ACCESS_KEY_ID,
                ) as client:
                    chunk_size = response.chunk_size
                    # print("response bucket + key: ", response.bucket, response.key)
                    minio_response = await client.get_object(Bucket=response.bucket, Key=response.key)
                    async with minio_response["Body"] as stream:
                        chunks = []
                        send_size = 0
                        more_body = True
                        while more_body:
                            chunk = await stream.read(chunk_size)
                            chunk_len = len(chunk)
                            # print("chunk len: ", chunk_len)
                            # more_body = chunk_len == chunk_size
                            more_body = chunk_len > 0
                            chunks.append(chunk)
                            await send(
                                {
                                    "type": "http.response.body",
                                    "body": chunk,
                                    "more_body": more_body,
                                }
                            )
                            send_size += chunk_len
                        # print("send size: ", send_size)




            else:
                # Access `__iter__` and not `streaming_content` directly in case
                # it has been overridden in a subclass.
                for part in response:
                    for chunk, _ in self.chunk_bytes(part):
                        await send(
                            {
                                "type": "http.response.body",
                                "body": chunk,
                                # Ignore "more" as there may be more parts; instead,
                                # use an empty final closing message with False.
                                "more_body": True,
                            }
                        )
                # Final closing message.
                await send({"type": "http.response.body"})
        # Other responses just need chunking.
        else:
            # Yield chunks of response.
            for chunk, last in self.chunk_bytes(response.content):
                await send(
                    {
                        "type": "http.response.body",
                        "body": chunk,
                        "more_body": not last,
                    }
                )
        await sync_to_async(response.close, thread_sensitive=True)()